---
layout: post
title: "머신러닝을 통한 사물함 반납 상태 확인 알고리즘 구축"
date: 2025-12-17 21:00:00 +0900
description: >
  사물함 점유 상태 판별 시스템의 기술적인 내용을 담고 있습니다.
categories: [42_cabinet]
tags: [machine-learning, hog, svm, fastapi]
---

# 머신러닝을 통한 사물함 반납 상태 확인 알고리즘 구축

본 문서는 사물함 점유 상태 판별 시스템의 기술적인 내용을 담고 있습니다. 프로젝트를 이어받는 팀원이 시스템의 전반적인 아키텍처와 각 모듈의 역할을 이해할 수 있도록 작성되었습니다.

---

## 목차

1. [데이터셋 구축](#1-데이터셋-구축)
2. [특징 추출 모듈 개발](#2-특징-추출-모듈-개발)
3. [모델 학습 및 저장 모듈](#3-모델-학습-및-저장-모듈)
4. [추론 엔진 개발](#4-추론-엔진-개발)

---

## 1. 데이터셋 구축

### 데이터 분류 체계

본 시스템은 이진 분류(Binary Classification) 문제를 다룹니다. 학습 데이터는 두 개의 클래스로 구분됩니다.

| 클래스 | 디렉토리 | 설명 |
|--------|----------|------|
| empty | `data/train/empty/` | 비어있는 사물함 이미지 |
| occupied | `data/train/occupied/` | 물건이 있는 사물함 이미지 |

### 데이터 증강 (Data Augmentation)

소규모 데이터셋의 한계를 극복하기 위해 증강 기법을 적용합니다. `scripts/augment_data.py`에서 다음과 같은 변환을 수행합니다.

| 기법 | 목적 |
|------|------|
| 회전 (-10, +10도) | 카메라 기울기 변화에 대한 강건성 확보 |
| 좌우 반전 | 물체 위치에 대한 불변성 학습 |
| 밝기 조정 (70%, 130%) | 다양한 조명 환경 대응 |
| 대비 조정 (80%, 120%) | 흐린 날씨나 직사광선 환경 대응 |
| 가우시안 노이즈 | 카메라 센서 노이즈 및 압축 아티팩트 대응 |
| 복합 증강 | 여러 기법을 조합하여 현실적인 변형 생성 |

증강을 통해 원본 데이터 대비 약 11배의 학습 데이터를 확보할 수 있습니다.

### 데이터 관리

대용량 학습 데이터는 Git 저장소에 포함하지 않고 Google Drive를 통해 공유합니다. `.env` 파일에 파일 ID를 설정한 후 `scripts/download_data.sh` 스크립트로 다운로드할 수 있습니다. 데이터 증강에서 사용되는 이미지 변환 기법들(Affine 변환, 히스토그램 조작 등)의 수학적 원리에 대해 더 공부해 보면 좋습니다.

---

## 2. 특징 추출 모듈 개발

### HOG (Histogram of Oriented Gradients) 알고리즘

HOG는 객체 인식을 위해 이미지에서 특징을 추출하는 알고리즘입니다. 본 시스템에서는 사물함 내부의 물체 유무를 판별하기 위한 핵심 특징으로 사용됩니다.

### 동작 원리

HOG는 이미지의 국소적인 밝기 변화(그래디언트)를 기반으로 특징을 추출합니다.

1. **셀 분할**: 이미지를 8x8 픽셀 단위의 셀로 분할합니다.
2. **그래디언트 계산**: 각 픽셀에서 x, y 방향의 밝기 변화를 계산합니다.
3. **방향 히스토그램 생성**: 그래디언트의 방향을 9개 구간(0-180도를 20도씩)으로 나누어 히스토그램을 만듭니다.
4. **블록 정규화**: 2x2 셀을 하나의 블록으로 묶고 L2-Hys 정규화를 적용하여 조명 변화에 강건하게 만듭니다.
5. **특징 벡터 생성**: 모든 블록의 히스토그램을 연결하여 최종 특징 벡터를 생성합니다.

### 파라미터 설정

```
이미지 크기: 128 x 128
pixels_per_cell: (8, 8)
cells_per_block: (2, 2)
orientations: 9
```

128을 8로 나누면 16개의 셀이 됩니다. 블록은 겹쳐서 이동하므로 (16-1) x (16-1) = 225개의 블록이 생성됩니다. 각 블록에서 2x2x9 = 36개의 값이 나오므로, 최종 특징 벡터의 차원은 225 x 36 = 8,100입니다.

### 전처리 파이프라인

`app/preprocess.py`에서 다음 순서로 전처리를 수행합니다.

```
원본 이미지 -> 리사이즈 (128x128) -> 그레이스케일 -> [선택] Gaussian Blur -> HOG 추출
```

Gaussian Blur는 이미지의 고주파 노이즈를 제거하여 HOG가 더 안정적인 특징을 추출하도록 돕습니다. 현재 모델 v1.1.0에서는 Blur를 적용하고 CLAHE는 비적용합니다.

HOG 알고리즘의 수학적 배경(그래디언트 계산, L2-Hys 정규화)과 다른 특징 추출 기법(SIFT, SURF, LBP)과의 비교에 대해 더 공부해 보면 좋습니다.

---

## 3. 모델 학습 및 저장 모듈

### Linear SVM (Support Vector Machine)

SVM은 두 클래스를 가장 잘 분리하는 결정 경계(초평면)를 찾는 알고리즘입니다. 고차원 특징 공간(8,100차원)에서도 효과적으로 동작하며, HOG 특징과 조합했을 때 이미지 분류에서 좋은 성능을 보입니다.

### 핵심 개념

- **마진(Margin)**: 결정 경계와 가장 가까운 데이터 포인트(서포트 벡터) 사이의 거리입니다. SVM은 이 마진을 최대화하는 방향으로 학습합니다.
- **정규화 파라미터 C**: 마진의 크기와 분류 오류 사이의 균형을 조절합니다. C가 크면 분류 오류를 줄이는 방향으로, 작으면 마진을 넓히는 방향으로 동작합니다.

### 학습 파이프라인 구조

`scripts/train.py`에서 다음과 같은 구조로 모델을 학습합니다.

```
StandardScaler -> LinearSVC -> CalibratedClassifierCV
```

1. **StandardScaler**: 특징 벡터를 평균 0, 분산 1로 정규화합니다. SVM은 특징의 스케일에 민감하므로 필수적인 전처리입니다.
2. **LinearSVC**: 선형 SVM 분류기입니다. 고차원 데이터에서 효율적으로 동작합니다.
3. **CalibratedClassifierCV**: SVM의 결정 함수 출력을 확률값으로 변환합니다. 3-fold 교차 검증을 통해 캘리브레이션을 수행합니다.

### 모델 저장 형식

학습된 모델은 joblib을 사용하여 `.pkl` 파일로 저장됩니다. 파일에는 모델 객체뿐만 아니라 전처리 설정과 메타데이터도 함께 저장됩니다.

```python
{
    'model': CalibratedClassifierCV,  # 학습된 모델 객체
    'preprocessing': {
        'use_clahe': False,
        'use_blur': True,
        'image_size': (128, 128)
    },
    'metadata': {
        'accuracy': 0.95,
        'data_dir': 'data/train',
        ...
    }
}
```

이 구조 덕분에 추론 시 학습 때와 동일한 전처리 설정을 자동으로 적용할 수 있습니다.

SVM의 이론적 배경(라그랑주 쌍대 문제, 커널 트릭)과 확률 캘리브레이션 기법(Platt Scaling, Isotonic Regression)에 대해 더 공부해 보면 좋습니다.

---

## 4. 추론 엔진 개발

### 원래 설계와 현재 구현의 차이

초기 설계에서는 단순한 함수 호출 방식을 목표로 했습니다. 그러나 실제 서비스 환경을 고려하여 REST API 서버로 확장되었습니다.

| 항목 | 초기 설계 | 현재 구현 |
|------|----------|----------|
| 인터페이스 | 함수 호출 | REST API (POST /predict) |
| 입력 | 로컬 파일 경로 | HTTP multipart/form-data |
| 출력 | `True`/`False` | JSON (status, confidence, latencyMs) |
| 상태 값 | 2가지 | 3가지 (OCCUPIED/EMPTY/UNKNOWN) |
| 예측 방식 | `predict()` (0/1) | `predict_proba()` (확률) |

이러한 변경은 다른 서비스(프론트엔드, 모바일 앱)에서 HTTP로 호출할 수 있게 하고, 모델의 확신도가 낮은 경계 상황을 별도로 처리하기 위함입니다.

### 시스템 아키텍처

추론 엔진은 FastAPI 기반의 REST API 서버로 구현되어 있습니다. 클라이언트가 이미지를 업로드하면 HOG 특징을 추출하고 SVM 모델로 분류한 결과를 반환합니다.

```
[클라이언트] --이미지--> [FastAPI 서버] --특징--> [SVM 모델] --확률--> [상태 판정]
```

### API 엔드포인트

| 엔드포인트 | 메서드 | 설명 |
|------------|--------|------|
| `/health` | GET | 서버 상태 확인 |
| `/predict` | POST | 이미지 분류 수행 |

### 추론 흐름

`app/main.py`의 `/predict` 엔드포인트에서 다음 순서로 처리됩니다.

1. **이미지 수신**: multipart/form-data로 이미지 파일을 받습니다.
2. **디코딩**: OpenCV를 사용하여 바이트 데이터를 numpy 배열로 변환합니다.
3. **색상 공간 변환**: BGR에서 RGB로 변환합니다.
4. **HOG 추출**: 저장된 전처리 설정을 적용하여 특징 벡터를 추출합니다.
5. **예측**: SVM 모델의 `predict_proba`를 호출하여 각 클래스의 확률을 얻습니다.
6. **상태 판정**: 확률 임계값에 따라 상태를 결정합니다.

### 상태 판정 기준

| 조건 | 상태 | 의미 |
|------|------|------|
| occupied_prob >= 0.6 | OCCUPIED | 물건이 있음 |
| occupied_prob <= 0.4 | EMPTY | 비어있음 |
| 0.4 < occupied_prob < 0.6 | UNKNOWN | 판단 불가 |

UNKNOWN 상태는 모델의 확신도가 낮은 경계 영역에서 발생합니다. 이 경우 클라이언트 측에서 재촬영을 요청하거나 수동 확인을 유도할 수 있습니다. 초기 설계에서는 이진 분류만 고려했으나, 실제 운영 환경에서는 경계 케이스 처리가 중요합니다.

### 성능 최적화

- **모델 사전 로드**: 서버 시작 시(`@app.on_event("startup")`) 모델을 메모리에 로드하여 요청마다 파일을 읽는 오버헤드를 제거합니다.
- **전역 상태 관리**: 모델 객체와 전처리 설정을 전역 변수로 관리하여 반복 로드를 방지합니다.

### CLI 예측 도구

API 서버 외에도 `scripts/predict.py`를 통해 로컬에서 직접 예측을 수행할 수 있습니다. 이는 초기 설계의 함수 호출 방식과 유사한 사용 경험을 제공합니다.

```bash
python scripts/predict.py data/train/occupied/sample.jpg
```

비동기 처리(async/await)의 동작 원리와 FastAPI의 의존성 주입(Dependency Injection) 패턴에 대해 더 공부해 보면 좋습니다.

---

## 부록: 기술 스택 정리

| 구분 | 기술 | 용도 |
|------|------|------|
| 특징 추출 | scikit-image (HOG) | 이미지에서 그래디언트 기반 특징 추출 |
| 이미지 처리 | OpenCV | 리사이즈, 색상 변환, 블러 등 전처리 |
| 모델 | scikit-learn (LinearSVC) | 선형 SVM 분류기 |
| 확률 보정 | CalibratedClassifierCV | SVM 출력을 확률로 변환 |
| 모델 저장 | joblib | 모델 직렬화 및 저장 |
| API 서버 | FastAPI + Uvicorn | RESTful API 서버 |

---

## 참고 사항

본 시스템은 HOG+SVM 조합을 사용하는 전통적인 머신러닝 기반 접근법입니다. 현재 95%의 정확도를 달성하고 있으며, 추후 데이터가 충분히 축적되면 딥러닝(CNN) 기반 모델로의 전환을 고려할 수 있습니다.
