---
layout: post
title: "GraphQL Request"
date: 2025-10-29 16:00:00 +0900
description: >
  GraphQL에 대해서 간단히 알아보고, 백엔드 서버로의 요청 방식에 대해 알아봅니다.
categories: [pick]
tags: [amplify, graphql]
---

GraphQL 요청은 스키마 정의, 사용자 요청, 응답 생성 크게 3개의 과정으로 나눌 수 있으며 해당 프로젝트에서는 Amplify(응답 생성 역할)를 이용하므로, 스키마 정의, 사용자 요청의 방법만을 다룰 것이다.

사용자 요청은 Query, Mutation, Subscription 3개로 구분되며 각 종류에 맞는 스키마 정의와 함께 정리해보려고 한다.

## Query

주로 데이터 조회(Read) 목적으로 사용되며 REST API의 GET과 비슷한 역할을 한다.
DB 데이터에 변화는 일어나지 않으며, 단일 요청-응답(HTTP) 구조의 통신을 사용한다.

### 스키마 정의

```graphql
type User {
  id: ID!
  name: String!
  email: String!
}

type Query {
  getUser(id: ID!): User
}
```

### 사용자 요청

```graphql
query {
  getUser(id: 1) {
    name
    email
  }
}
```

### 응답

```json
{
  "data": {
    "getUser": {
      "name": "홍길동",
      "email": "example@example.com"
    }
  }
}
```

## Mutation

데이터 변경(Create, Update, Delete)의 목적으로 사용되며 데이터의 변화가 일어나는 요청이다.
Query와 마찬가지로 단일 요청-응답(HTTP) 통신 구조를 사용한다.

### 스키마 정의

```graphql
type User {
  id: ID!
  name: String!
  email: String!
}

input CreateUserInput {
  name: String!
  email: String!
}

type Mutation {
  createUser(input: CreateUserInput!): User
  # createUser(name: String!, email: String!) 과 동일
}
```

### 사용자 요청

```graphql
mutation {
  createUser(name: "홍길동", email: "example@example.com") {
    id
    name
  }
}
```

### 응답

```json
{
  "data": {
    "createUser": {
      "id": 1,
      "name": "홍길동"
    }
  }
}
```

## Subscription

데이터 실시간 구독(Listen)을 할 때 사용되며 WebSocket을 기반으로 통신한다.

### 스키마 정의

```graphql
type Message {
  text: String!
  sender: String!
}

type Subscription {
  onNewMessage: Message
}
```

### 사용자 요청

```graphql
subscription {
  onNewMessage {
    text
    sender
  }
}
```

### 응답

```json
{
  "data": {
    "onNewMessage": {
      "text": "안녕!",
      "sender": "길동이"
    }
  }
}
```

**참고자료**
https://graphql.org/learn/
