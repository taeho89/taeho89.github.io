---
layout: post
title: "C++ 레퍼런스 변수는 진짜 메모리를 안먹을까?"
date: 2025-10-30 20:00:00 +0900
description: >
  포인터 변수와 레퍼런스 변수가 내부적으로 어떻게 구현되어 있는지 확인하고 무슨 차이가 있는 지 살펴봅니다.
categories: [42, CPP]
tags: [CPP, Assembly]
---

C++를 공부하다 보면 **"레퍼런스(참조자)는 변수의 별명일 뿐, 실제 메모리 공간을 차지하지 않는다"**는 말을 듣곤 한다. 포인터와 달리 별도의 변수가 생성되는 게 아니라는 뜻이다.

과제를 하던 중 문득 이 말이 **물리적인 메모리 레벨**에서도 진짜일지 의심이 들었다. 그래서 직접 찍어봤다. 결과는 내 예상을 완전히 뒤엎었다.

## 1. 사건의 발단: 수상한 주소값

실험은 간단했다. `int` 변수 3개와 `int&` 레퍼런스 1개를 인자로 받는 함수를 만들고, 각 변수의 주소값을 출력해봤다.

```cpp
void func(int a, int& b, int c, int d) {
    std::cout << &a << std::endl;
    std::cout << &b << std::endl; // 과연 b 자신의 주소가 나올까?
    std::cout << &c << std::endl;
    std::cout << &d << std::endl;
}
```

```bash
# 실제 출력 결과
0x7ffd498abadc # a의 주소
0x7ffd498abaf8 # b의 주소 (실제 원본의 주소)
0x7ffd498abad8 # c의 주소
0x7ffd498abacc # d의 주소
```

결과를 뜯어보니 이상한 점이 한두 개가 아니었다.

1.  **`b` 혼자 딴 세상에 있다:** `a`, `c`, `d`는 `dc` -> `d8` -> `cc`로 오밀조밀하게 모여 있는데, `b`만 `f8`이라는 먼 곳을 가리키고 있다.
    - **이유:** C++ 문법상 `&b`를 하면 **레퍼런스 변수 자체의 주소**가 아니라, **b가 가리키는 원본 변수의 주소**가 나오기 때문이다. 즉, C++ 코드만으로는 **"레퍼런스 변수 `b`가 스택 어디에 살고 있는지"** 알아낼 방법이 없다.
2.  **빈 공간(Gap)의 미스터리:** `a`(4바이트), `c`(4바이트), `d`(4바이트)라면 총 12바이트면 충분할 텐데, 주소값 사이의 간격을 계산해보면 중간중간 묘하게 비어있는 공간들이 보인다.

"분명 레퍼런스 `b`도 어딘가에 저장되어 있을 텐데..."
결국 눈에 보이지 않는 진실을 찾기 위해 **어셈블리 까보기(`-S`)**를 시전했다.

## 2. 어셈블리가 말해주는 진실

소스 코드를 어셈블리어로 변환(`g++ -S`)하여 함수 내부가 실제로 어떻게 돌아가는지 확인했다. 그리고 충격적인(사실은 당연한) 사실을 마주했다.

### 2.1. 레퍼런스의 본체는 '포인터'다

호출하는 쪽(`main`)에서 인자를 넘겨주는 부분을 보자.

```assembly
leaq    4(%rsp), %rsi      ; 변수의 주소(&)를 계산해서 레지스터에 담음
call    _Z5printiRiii      ; 함수 호출
```

놀랍게도(혹은 허무하게도) **포인터를 넘길 때와 토씨 하나 안 틀리고 똑같다.**
레퍼런스는 마법의 별명이 아니라, 내부적으로 **주소값(8바이트)**을 저장하는 **포인터 변수**로 구현되어 있었다. 즉, "메모리를 차지하지 않는다"는 말은 잘못 알고 있던 것이었다. 레퍼런스 변수 하나당 꼬박꼬박 **8바이트(64bit 주소)**를 차지하고 있었다.

### 2.2. 사라진 공간의 범인은 '패딩(Padding)'

아까 주소값 사이사이에 비어있던 공간의 정체도 밝혀졌다.
`int`(4바이트)와 `Reference`(내부적인 8바이트 포인터)가 섞여 있다 보니, 컴파일러가 CPU 성능을 위해 **데이터 정렬(Alignment)**을 하면서 빈 공간(패딩)을 쑤셔 넣은 것이었다.

결국 내 스택 프레임은 **[int 12바이트]**만 있는 깔끔한 방이 아니라, **[int + 패딩 + 포인터(레퍼런스) + 패딩]**이 뒤섞인 꽤 넓은 방이었다.

## 3. 반전: 그래도 레퍼런스를 써야 하는 이유

"이럴 거면 그냥 포인터 쓰지 왜 레퍼런스를 써?"라는 생각이 들 때쯤, 최적화 옵션(`-O2`)을 켠 어셈블리 코드에서 **결정적인 차이**를 발견했다.

**[포인터로 짰을 때]**

```assembly
subq    $32, %rsp          ; 스택을 32바이트나 씀
movq    %rsi, 16(%rsp)     ; 주소값을 굳이 스택 메모리에 저장함
```

포인터는 "언제든 다른 놈을 가리킬 수 있다"는 배신 가능성 때문에, 컴파일러가 보수적으로 **스택 메모리**에 값을 저장해둔다.

**[레퍼런스로 짰을 때]**

```assembly
subq    $24, %rsp          ; 스택을 24바이트만 씀 (8바이트 절약!)
pushq   %rbx               ; 스택 대신 레지스터(RBX) 사용
movq    %rsi, %rbx         ; 주소값을 레지스터에 꽂아두고 씀
```

반면 레퍼런스는 **"태어날 때 정한 놈만 평생 바라본다(불변성)"**는 지조가 있다. 컴파일러는 이 점을 믿고, 느려터진 메모리(스택) 대신 **가장 빠른 저장소인 CPU 레지스터**에 주소를 박아버리는 최적화를 감행했다.

## 4. 결론

오늘의 삽질을 통해 얻은 결론은 다음과 같다.

1.  **레퍼런스도 메모리를 먹는다:** 내부적으로는 포인터와 똑같이 주소값(8바이트)을 들고 다닌다.
2.  **우리가 못 볼 뿐이다:** C++ 문법이 레퍼런스 자체의 주소 접근을 막아놔서 없는 것처럼 보일 뿐, 어셈블리 단에서는 엄연히 존재한다.
3.  **하지만 더 빠르다:** 레퍼런스의 '불변성' 덕분에 컴파일러가 **레지스터 할당 최적화**를 할 수 있다.

**한 줄 요약:** 레퍼런스는 **"메모리는 포인터만큼 쓰지만, 포인터보다 더 똑똑하고 안전하게 최적화되는 포인터의 진화형"**이다.
