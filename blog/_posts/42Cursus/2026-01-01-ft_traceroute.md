---
layout: post
title: "ft_traceroute 환경 설정"
date: 2026-01-01 16:00:00 +0900
description: >
  과제 요구 사항을 충족하기 위한 환경 설정 과정
categories: [42, C]
tags: [C]
---

### 1. 가상머신 네트워크 모드에 따른 동작 차이

- NAT 모드와 '가로채기' 현상
  증상: traceroute -I 8.8.8.8 실행 시, 첫 번째 홉(TTL=1) 만에 목적지인 구글 DNS에 도달하는 현상 발생.

  원인: VirtualBox의 NAT 엔진이 중간 프록시 역할을 하기 때문입니다. 가상머신이 보낸 ICMP 요청을 NAT 엔진이 가로채서 대신 외부와 통신한 뒤 결과를 즉시 반환하므로, 실제 인터넷 경로가 생략되고 1홉 만에 끝나는 것처럼 보입니다.

  결과: 실제 경로 추적은 불가능하지만, 외부 인터넷 연결(패킷 송수신) 자체는 가장 안정적입니다.

- 브릿지 모드(Bridged Adapter) 시도와 한계
  목적: NAT 엔진의 간섭을 없애고 가상머신이 공유기로부터 직접 IP를 할당받아 실제 네트워크 경로를 확인하고자 했습니다.

  문제 발생: 브릿지 모드 전환 후 HostIfNotConnecting 및 BridgedInterfaceDown 오류 발생.

  원인: 호스트 PC의 물리적 네트워크 카드 이름(예: enp0s31f6)과 가상머신 설정이 일치하지 않았거나, 해당 인터페이스가 비활성화(DOWN) 상태였기 때문입니다. 이로 인해 가상머신 내 인터페이스가 NO-CARRIER 상태가 되어 통신이 두절되었습니다.

### 2. 패킷 분석을 통한 로직 정상 동작 검증 (tshark)

네트워크 환경의 제약(NAT 모드)으로 인해 결과값이 * * *로 나오거나 1홉 만에 종료되더라도, 작성한 코드가 정상인지 확인하기 위해 tshark를 활용해 패킷 레벨에서 검증을 수행했습니다.

- 검증 명령어

```Bash
sudo tshark -i enp0s3 -f "udp or icmp" -T fields \
-e ip.src -e ip.dst -e ip.ttl -e _ws.col.Info

# -f "udp or icmp": 리눅스 traceroute가 발신하는 UDP와 라우터가 응답하는 ICMP를 모두 캡처합니다.
# -e ip.ttl: IP 헤더의 TTL 값을 직접 출력하여 코드의 핵심 로직인 setsockopt(..., IP_TTL, ...)이 실제 패킷에 반영되는지 확인합니다.
```

- 검증 결과 해석
  발신 패킷(UDP): 내가 보낸 패킷들의 TTL 값이 1, 1, 1, 2, 2, 2... 순으로 정확히 3번씩 증가하며 나가는지 확인했습니다.

  수신 패킷(ICMP): 외부 경로가 차단되더라도, 최소한 게이트웨이(10.0.2.2) 등에서 Time-to-live exceeded (Type 11) 메시지가 돌아오는지 확인했습니다.

  결론: 출력 결과가 실제 도구와 다르더라도, Wireshark 로그상에서 TTL이 순차적으로 증가하고 있다면 traceroute의 핵심 원리인 'TTL 조작을 통한 경로 추적' 로직이 완벽히 구현된 것으로 판단할 수 있습니다.

### 3. 과제 구현 핵심 요약 및 팁

커널 버전: 과제 요구사항인 Linux Kernel 4.0 이상 조건을 충족하기 위해 최신 데비안 환경을 유지했습니다.

출력 형식: 실제 traceroute와 동일한 인덴트(들여쓰기)를 맞추기 위해 홉 번호, IP 주소, RTT(응답 시간)의 출력 포맷을 정교하게 조정했습니다.

Raw Socket 권한: IPPROTO_ICMP 및 IPPROTO_UDP를 직접 다루기 위해 sudo 권한으로 실행하며 로우 소켓 프로그래밍을 수행했습니다.
