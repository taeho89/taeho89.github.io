---
layout: post
title: "백준 18870 좌표 압축"
date: 2025-12-25 17:29:00 +0900
description: >
  정렬, 좌표 압축
categories: [codingTest]
tags: [코테, 정렬, 좌표 압축]
---

## 시간 초과 발생 원인 및 코드 분석

1. 성공한 코드 분석 (Vector + lower_bound)
   첫 번째 코드는 std::vector와 std::lower_bound(이분 탐색)를 사용하여 효율적으로 동작함.
   시간 복잡도: `$O(N \log N)$`
   분석: 정렬(`$N \log N$`) 후, 각 원소에 대해 이분 탐색(`$\log N$`)을 수행하므로 `$N$`이 1,000,000이어도 제한 시간 내에 충분히 통과함.

```C++
// 통과된 핵심 로직
sort(v2.begin(), v2.end());
v2.erase(unique(v2.begin(), v2.end()), v2.end());

for (int i = 0; i < N; i++) {
  // 이분 탐색을 통해 O(log N)으로 위치를 찾음
  cout << lower_bound(v2.begin(), v2.end(), arr[i]) - v2.begin() << " ";
}
```

2. 실패한 코드 분석 (Map/Set + Linear Scan)
   두 번째, 세 번째 코드는 std::map을 사용했음에도 불구하고 시간 초과가 발생함. 원인은 Map의 장점인 Key 조회를 사용하지 않고 반복문으로 순회했기 때문임.
   시간 복잡도: `$O(N^2)$`
   분석: solve() 함수 내부를 보면, 입력 배열 arr의 모든 원소에 대해 map 전체를 처음부터 끝까지 훑는 이중 반복문 구조임.
   입력 크기 `$N$`이 최대 `$1,000,000$`일 때, 연산 횟수는 약 `$10^{12}$`(1조)회에 달해 시간 제한을 초과함.

```C++
// 시간 초과가 발생한 핵심 로직 (코드 2, 3 동일)
for (vector<int>::iterator it = arr.begin(); it != arr.end(); it++) { // Outer Loop: N회

    // Inner Loop: Map의 크기(K)만큼 매번 전체 순회 (문제 발생 지점)
    // Map을 효율적인 트리가 아닌 단순 리스트처럼 사용하고 있음
    for (map<int, int>::iterator mit = m.begin(); mit != m.end(); mit++) {
        if (*it == mit->first) {
            *it = mit->second;
            break;
        }
    }
}
```

3. 해결 방안 (Map의 올바른 사용)
   C++의 std::map은 Red-Black Tree로 구현되어 있어, Key를 이용한 접근 시 `$O(\log N)$`의 속도를 보장함. 반복문(`for`)을 제거하고 인덱스 연산자(`[]`)나 `find()`를 사용해야 함.
   수정된 로직 시간 복잡도: `$O(N \log N)$`

```C++
// 수정 제안 코드
void solve() {
    map<int, int> m;

    // (중략: 맵 생성 과정)

    // 이중 반복문 제거 -> Key를 통해 즉시 값에 접근
    for (int i = 0; i < N; i++) {
        arr[i] = m[arr[i]]; // O(log K) 속도로 값 변환
    }
}
```

## 요약

성공한 코드는 이분 탐색을 활용하여 `$O(\log N)$`으로 값을 찾음.
실패한 코드는 Map을 사용했으나, 내부 데이터를 선형 탐색(Linear Scan)하여 `$O(N)$`으로 값을 찾음. 전체 복잡도가 `$O(N^2)$`가 되어 실패함.
Map을 사용할 때는 반복자(iterator)로 순회하며 비교하지 말고, m[key]와 같이 Key로 직접 접근해야 성능 저하를 막을 수 있음.
