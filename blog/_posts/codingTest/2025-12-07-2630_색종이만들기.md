---
layout: post
title: "백준 2630 색종이 만들기"
date: 2025-12-7 15:23:00 +0900
description: >
  분할 정복, 재귀
categories: [codingTest]
tags: [코테, 분할 정복, 재귀]
---

> [2630. 색종이만들기](https://www.acmicpc.net/problem/2630)

## 처음 풀이

처음에 기준이 되는 점의 값을 불러오고 (0 또는 1)
size * size 영역이 그 기준 값과 모두 같으면 0이면 white++, 1이면 blue++을 통해 카운트하고, 해당 필드를 -1로 마킹하여 이미 처리되었음을 표시했다.
이후 다음 반복, 더 작은 size 단위의 재귀에서 -1로 체크된 영역을 skip하게 하여 중복을 방지했다.

```cpp
#include <iostream>

using namespace std;

void find_paper(int size);
void checked(int size, int x, int y);

int N;
int map[128][128];
int white = 0;
int blue = 0;

int main(void) {
  cin.tie(nullptr);
  ios_base::sync_with_stdio(false);

  cin >> N;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      cin >> map[i][j];
    }
  }

  find_paper(N);

  cout << white << '\n' << blue << '\n';
  return 0;
}

void find_paper(int size) {
  if (size == 0) {
    return;
  }

  for (int i = 0; i < N / size; i++) {
    for (int p = 0; p < N / size; p++) {
      int invalid = 0;
      int pos_x = p * size;
      int pos_y = i * size;
      int first = map[pos_y][pos_x];
      if (first == -1) {
        continue;
      }
      for (int j = 0; j < size; j++) {
        for (int k = 0; k < size; k++) {
          if (map[pos_y + j][pos_x + k] == first) {
            continue;
          } else {
            invalid = 1;
            break;
          }
        }
        if (invalid)
          break;
      }
      if (!invalid) {
        if (first)
          blue++;
        else
          white++;
        checked(size, pos_x, pos_y);
      }
    }
  }
  find_paper(size / 2);
}

void checked(int size, int x, int y) {
  for (int i = y; i < y + size; i++) {
    for (int j = x; j < x + size; j++) {
      map[i][j] = -1;
    }
  }
}
```

## 정석적인 풀이?

**전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다.**라는 문제의 문장을 그대로 구현하는 방법에 가까우며 정석적인 풀이에 가깝다고 생각한다.

```cpp
#include <iostream>

using namespace std;

int N;
int white = 0;
int blue = 0;
int board[128][128];

void solve(int size, int x, int y) {
  int first = board[y][x];
  int invalid = 0;
  for (int i = y; i < y + size; i++) {
    for (int j = x; j < x + size; j++) {
      if (board[i][j] != first) {
        invalid = 1;
      }
    }
  }
  if (invalid) {
    solve(size / 2, x, y);
    solve(size / 2, x + size / 2, y);
    solve(size / 2, x, y + size / 2);
    solve(size / 2, x + size / 2, y + size / 2);
    return;
  }
  if (first)
    blue++;
  else
    white++;
};

int main(void) {
  cin.tie(nullptr);
  ios_base::sync_with_stdio(false);

  cin >> N;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
      cin >> board[i][j];
    }
  }
  solve(N, 0, 0);
  cout << white << '\n';
  cout << blue << '\n';
}
```
