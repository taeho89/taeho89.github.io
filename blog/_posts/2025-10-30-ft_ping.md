---
layout: post
title: "ft_ping"
date: 2025-10-30 20:00:00 +0900
description: >
  ping 유틸리티를 C언어를 이용하여 구현해봅니다.
categories: [42, C]
tags: [C]
---

## 리눅스 RAW 소켓으로 재구현한 ft_ping

### 들어가며

42 커리큘럼 중 `ft_ping` 프로젝트는 네트워크 스택의 가장 하단을 직접 만져 볼 수 있는 과제다. 기존 `ping(8)` 유틸리티가 하는 일을 C99와 표준 라이브러리만으로 재현하면서, ICMP 패킷 구조·소켓 API·시간 계산 등을 깊이 이해하는 것이 목표였다. 이 글에서는 내가 구현한 `ft_ping`의 구조와 핵심 로직을 코드와 함께 정리한다.

---

### 전체 구조

- `main.c`: 옵션 파싱과 이벤트 루프 진입
- `init.c`: 목적지 해석, RAW 소켓/시그널 FD 초기화, 전송 타임스탬프 링버퍼 할당
- `ping.c`: Echo Request 생성/전송, Reply 파싱, RTT 통계 누적
- `validate.c`: IPv4/ICMP 헤더 검증과 페이로드 무결성 확인
- `ping_output.c`: 응답/에러 메시지·통계 출력
- `utils.c`: 체크섬, 시간 계산, 리소스 해제 등 공통 함수

프로젝트 전역에서 사용하는 구조체(`ping_rts_t`, `statistic_t`, `reply_t`)와 매크로는 `includes/ping.h`에 정리했다.

---

### RAW 소켓 초기화와 대상 설정

RAW 소켓을 직접 열기 때문에 목적지 IP를 스스로 해석하고, 커널이 제공하는 시그널을 `signalfd`로 읽기 위해 별도 파일 디스크립터를 준비한다.

```c
// srcs/init.c
int	init_rts(ping_rts_t *rts, statistic_t *stat, char *dst) {
	...
	rc = set_destination(rts, dst);         // getaddrinfo + inet_ntop
	rts->sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
	rts->sigfd = set_signal();              // SIGINT를 signalfd로 변환
	init_tsend(rts);                        // 전송 타임스탬프 링버퍼
	...
}
```

`set_destination`은 `getaddrinfo`를 이용해 IPv4 주소를 가져오고, 정방향 이름(`canonname`)을 `rts->src_host`에 저장한다. 이 값은 출력 메시지에서 사용된다.

`init_tsend`는 RTT 계산을 위해 `struct timespec`을 저장하는 두 배 크기 링버퍼를 할당한다. 시퀀스 번호가 순환할 때, 마스크 연산만으로 O(1)에 접근할 수 있도록 버퍼 크기를 2의 거듭제곱으로 맞춘 것이 특징이다.

---

### 이벤트 루프: poll + signalfd

전송 주기를 유지하면서 소켓과 SIGINT를 동시에 감시하기 위해 `poll`을 사용했다. `signalfd`로 등록된 FD는 사용자가 `Ctrl+C`를 누르면 활성화되어 곧바로 통계 출력을 트리거한다.

```c
// srcs/main.c
void	main_loop(ping_rts_t *rts) {
	struct pollfd pfd[2] = {
		{ .fd = rts->sockfd, .events = POLLIN },
		{ .fd = rts->sigfd,  .events = POLLIN }
	};

	printf("PING %s (%s) %d(%d) bytes data\n", ...);
	for (;;) {
		do {
			send_packet(rts, next);                      // 전송 간격 유지
			clock_gettime(CLOCK_MONOTONIC, &now);
			next = rts->interval - get_time_diff(rts->last_send, now);
		} while (next < 0);

		poll(pfd, 2, next);                              // 소켓/신호 이벤트 대기
		if (pfd[1].revents & POLLIN) {
			print_statistics(rts);
			break;
		}
		// 논블로킹 recvfrom 반복
		...
	}
}
```

`send_packet`은 호출 시점에 아직 다음 전송 시각이 아니라면 즉시 반환한다. 이렇게 하면 `poll` 타이머와 전송 간격 계산이 충돌하지 않는다.

---

### ICMP Echo Request 구성

Echo Request 패킷은 헤더 + 전송 시각 + 패딩으로 64바이트를 맞춘다. 전송 시각을 페이로드에 싣기 때문에 별도의 RTT 스토리지 없이도 응답 수신 시점의 차이를 계산할 수 있다.

```c
// srcs/ping.c
void	send_packet(ping_rts_t *rts, double next) {
	char packet[PACKET_SIZE];
	struct icmphdr icmp_hdr = {0};
	struct timespec tp;

	if (next > 0) return;                    // 다음 전송까지 대기

	icmp_hdr.type = rts->msg_type;           // 기본: ICMP_ECHO
	icmp_hdr.un.echo.id = htons(rts->id);
	icmp_hdr.un.echo.sequence = htons(rts->seq);

	memcpy(packet, &icmp_hdr, sizeof(icmp_hdr));
	clock_gettime(CLOCK_MONOTONIC, &tp);
	memcpy(packet + sizeof(icmp_hdr), &tp, sizeof(tp));
	memset(packet + sizeof(icmp_hdr) + sizeof(tp), 'a',
	       sizeof(packet) - sizeof(icmp_hdr) - sizeof(tp));
	((struct icmphdr *)packet)->checksum = checksum(packet, sizeof(packet));

	sendto(rts->sockfd, packet, sizeof(packet), 0,
	       (struct sockaddr *)&rts->dst, rts->socklen);
	rts->t_send[seq_to_index(rts->seq, rts->t_sendsize)] = tp;
	rts->last_send = tp;
	rts->stat->ntransmitted++;
	rts->seq++;
}
```

`checksum`은 RFC 1071에서 정의된 16비트 1의 보수 합을 그대로 구현한 함수로, `utils.c`에 위치한다.

---

### Reply 파싱과 RTT 계산

수신된 패킷은 IPv4 헤더와 ICMP 헤더를 각각 추려내고, 페이로드에서 송신 시각을 추출해 RTT를 산출한다. 유효성 검사는 `validate`에 위임하여 `parse_reply`가 깔끔하게 유지되도록 했다.

```c
// srcs/ping.c
int	parse_reply(ping_rts_t *rts, char *packet, int cc) {
	reply_t reply = { .packet = packet };
	struct timespec tp, send_time;

	memcpy(&reply.ip4_hdr, packet, sizeof(reply.ip4_hdr));
	reply.ip4_len = reply.ip4_hdr.ihl * 4;
	memcpy(&reply.icmp_hdr, packet + reply.ip4_len, sizeof(reply.icmp_hdr));
	reply.payload = packet + reply.ip4_len + sizeof(reply.icmp_hdr);
	reply.payload_len = cc - reply.ip4_len - sizeof(reply.icmp_hdr);

	memcpy(&send_time, reply.payload, sizeof(send_time));
	clock_gettime(CLOCK_MONOTONIC, &tp);
	reply.rtt = (tp.tv_sec - send_time.tv_sec) * 1000.0
	          + (tp.tv_nsec - send_time.tv_nsec) / 1000000.0;

	int ret = validate(rts, &reply, cc);
	if (ret == 1) return 0;                  // loopback에서 ECHO request는 무시
	if (ret > 0) {
		print_error_result(&reply);
		rts->stat->nerrored++;
		return -1;
	}

	print_reply_result(&reply, cc, rts->input);
	statistic_rtt(rts, reply.payload, &tp);   // min/avg/max/mdev 업데이트
	return 0;
}
```

`statistic_rtt`는 최소·최대·합계·제곱합을 동시에 누적해서 마지막에 표준 ping과 동일한 `min/avg/max/mdev` 통계를 출력한다.

---

### 패킷 검증 로직

네트워크 상에서 돌아오는 모든 패킷이 신뢰할 수 있는 것은 아니다. `validate.c`는 다음과 같은 순서로 검사한다.

```c
// srcs/validate.c
int	validate(ping_rts_t *rts, reply_t *reply, int cc) {
	if (ntohs(reply->ip4_hdr.tot_len) != cc) return -1;           // 길이 불일치
	if (validate_ip4_hdr(&reply->ip4_hdr)) return -1;             // IPv4/ICMP 체크
	if (reply->icmp_hdr.type == ICMP_ECHO) return 1;              // 로컬 ECHO 요청 무시
	if (reply->icmp_hdr.type != ICMP_ECHOREPLY || reply->icmp_hdr.code != 0)
		return reply->icmp_hdr.type;                              // 오류 코드 처리
	if (validate_icmp(rts, &reply->icmp_hdr, reply->payload, reply->payload_len))
		return -1;                                                // ID/SEQ/Payload 불일치
	if (checksum(reply->packet + reply->ip4_len, cc - reply->ip4_len) != 0)
		return -1;                                                // 헤더+페이로드 체크섬
	return 0;
}
```

- `validate_ip4_hdr`: IPv4 버전, 프로토콜(ICMP), IHL 최소값(5) 확인
- `validate_icmp`: 식별자/시퀀스 번호가 내 요청과 일치하는지, 페이로드에 저장한 전송 시각과 패딩(`'a'`)이 변형되지 않았는지 확인
- 체크섬이 0이 아니면 페이로드가 손상되었다고 판단하고 버린다

오류 패킷의 경우 `print_error_result`가 원 주소, 호스트 이름, ICMP 타입에 따라 메시지를 포맷팅한다.

---

### 통계 출력과 종료 흐름

`Ctrl+C` 등으로 종료할 때는 `signalfd` 이벤트가 발생하고 곧바로 `print_statistics`가 호출된다.

```c
// srcs/ping_output.c
void	print_statistics(ping_rts_t *rts) {
	statistic_t *stat = rts->stat;
	double loss = ((stat->ntransmitted - stat->nrecved) /
	              (double)stat->ntransmitted) * 100.0;
	double runtime = get_time_diff(stat->st, rts->last_send);

	printf("\n--- %s ping statistics ---\n", rts->src_host);
	printf("%d packets transmitted, %d received", stat->ntransmitted, stat->nrecved);
	if (stat->nerrored) printf(", +%d errors", stat->nerrored);
	printf(", %d%% packet loss, time %.fms\n", (int)loss, runtime);

	if (stat->nrecved) {
		stat->avg_rtt = stat->rtt_sum / stat->nrecved;
		stat->mdev_rtt = sqrt(stat->rtt_sum2 / stat->nrecved
		                     - (stat->avg_rtt * stat->avg_rtt));
		printf("rtt min/avg/max/mdev = %.3f/%.3f/%.3f/%.3f ms\n",
		       stat->min_rtt, stat->avg_rtt, stat->max_rtt, stat->mdev_rtt);
	}
}
```

표준 `ping`과 동일한 형식의 요약을 출력하되, 에러 패킷이 있었다면 `+<count> errors` 항목을 추가로 보여준다.

---

### 수동 테스트 전략

- **루프백**: `./ft_ping 127.0.0.1` – RTT 계산과 통계 출력이 정상인지 확인
- **외부 호스트**: `./ft_ping example.com` – DNS 해석 결과(`canonname`)와 TTL, RTT를 확인
- **비도달 대상**: `./ft_ping 203.0.113.1` – ICMP Destination Unreachable 등이 올바로 표시되는지 점검
- **참조 비교**: 시스템 `ping`과 RTT/손실률/통계 형식이 크게 다르지 않은지 비교

RAW 소켓은 root 권한이 필요하므로, 일반 사용자 실행 시 `sudo setcap cap_net_raw+ep ./ft_ping`으로 권한을 부여한다.

---

### 마치며

ICMP Echo를 직접 구현하면서 네트워크 스택의 여러 레이어가 어떻게 맞물리는지 체감할 수 있었다. 특히

1. `signalfd` 기반 이벤트 루프를 구성해 프로세스 종료 흐름을 깔끔하게 정리한 점,
2. RTT 계산을 위한 타임스탬프 링버퍼 설계,
3. 패킷 검증 로직을 별도 모듈로 분리해 가독성과 테스트 용이성을 확보한 점

이 유용한 경험이었다. 다음 단계로는 `-c`, `-i`, `-t` 옵션 지원, IPv6 확장, 그리고 패킷 파서를 단위 테스트할 수 있는 모의 환경을 마련해 보고 싶다. 이 글이 RAW 소켓 및 ICMP 프로토콜을 처음 접하는 분들에게 참고가 되길 바란다.
